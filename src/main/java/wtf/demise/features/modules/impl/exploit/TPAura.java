package wtf.demise.features.modules.impl.exploit;

import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.Vec3;
import org.lwjglx.input.Mouse;
import wtf.demise.Demise;
import wtf.demise.events.annotations.EventTarget;
import wtf.demise.events.impl.misc.WorldChangeEvent;
import wtf.demise.events.impl.player.MotionEvent;
import wtf.demise.events.impl.render.Render3DEvent;
import wtf.demise.features.modules.Module;
import wtf.demise.features.modules.ModuleCategory;
import wtf.demise.features.modules.ModuleInfo;
import wtf.demise.features.modules.impl.combat.AntiBot;
import wtf.demise.features.modules.impl.combat.KillAura;
import wtf.demise.features.modules.impl.visual.Interface;
import wtf.demise.features.values.impl.BoolValue;
import wtf.demise.features.values.impl.ModeValue;
import wtf.demise.features.values.impl.SliderValue;
import wtf.demise.utils.math.TimerUtils;
import wtf.demise.utils.packet.PacketUtils;
import wtf.demise.utils.pathfinding.MainPathFinder;
import wtf.demise.utils.player.PlayerUtils;
import wtf.demise.utils.render.RenderUtils;

import java.awt.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

@ModuleInfo(name = "TPAura", category = ModuleCategory.Exploit)
public class TPAura extends Module {
    private final ModeValue mode = new ModeValue("Mode", new String[]{"Single", "Multi"}, "Single", this);
    private final SliderValue cps = new SliderValue("CPS", 5, 1, 20, 1, this);
    private final SliderValue range = new SliderValue("Range", 20, 4, 120, 1, this);
    private final SliderValue timerSpeed = new SliderValue("Timer", 1, 0.1f, 3, 0.1f, this);
    private final SliderValue maxTargets = new SliderValue("Max Targets", 25, 2, 50, 1, this);

    private final BoolValue players = new BoolValue("Players", true, this);
    private final BoolValue nonPlayers = new BoolValue("Non Players", true, this);
    private final BoolValue ignoreTeammates = new BoolValue("Ignore Teammates", true, this);
    private final BoolValue invisibles = new BoolValue("Invisibles", false, this);
    private final BoolValue attackDead = new BoolValue("Attack Dead", false, this);

    private final BoolValue render = new BoolValue("Render Line", true, this);
    private final BoolValue renderESP = new BoolValue("Render ESP", true, this);

    private final BoolValue disableOnWorldChange = new BoolValue("Disable On World Change", true, this);
    private final BoolValue attackInInterfaces = new BoolValue("Attack in Interfaces", false, this);
    private final BoolValue onClick = new BoolValue("On Click", false, this);

    private ArrayList<Vec3> path;
    private Entity target;
    private final TimerUtils timer = new TimerUtils();

    @EventTarget
    public void onWorldChanged(WorldChangeEvent e) {
        if (disableOnWorldChange.get()) {
            this.toggle();
        }
    }

    @EventTarget
    public void onPreMotion(MotionEvent e) {
        if (e.isPre()) {

            if (mc.currentScreen != null && !attackInInterfaces.get()) {
                target = null;
                path = null;
                return;
            }

            if (!(!onClick.get() || Mouse.isButtonDown(0) && mc.currentScreen == null)) {
                target = null;
                path = null;
                return;
            }


            if (!timer.hasTimeElapsed((long) (((20 - cps.get()) * 50) - Math.random() * 100))) return;

            timer.reset();

            final List<EntityLivingBase> targets = getEntities(range.get(), players.get(), nonPlayers.get(), attackDead.get(), invisibles.get(), ignoreTeammates.get());

            final int maxTargets = (int) Math.round(this.maxTargets.get());

            if (mode.is("Multi") && targets.size() > maxTargets)
                targets.subList(maxTargets, targets.size()).clear();

            if (targets.isEmpty()) {
                target = null;
                return;
            }

            target = targets.get(0);


            final EntityPlayer player = mc.thePlayer;

            double x = player.posX;
            double y = player.posY;
            double z = player.posZ;

            final double targetX = target.posX;
            final double targetY = target.posY;
            final double targetZ = target.posZ;

            mc.timer.timerSpeed = timerSpeed.get();

            final double finalZ = z;
            final double finalY = y;
            final double finalX = x;
            new Thread(() -> {
                switch (mode.get()) {
                    case "Single": {
                        path = MainPathFinder.computePath(new Vec3(finalX, finalY, finalZ), new Vec3(targetX, targetY, targetZ));

                        for (final Vec3 vec : path)
                            PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.xCoord, vec.yCoord, vec.zCoord, false));

                        mc.thePlayer.swingItem();

                        PacketUtils.sendPacketNoEvent(new C02PacketUseEntity(target, C02PacketUseEntity.Action.ATTACK));

                        Collections.reverse(path);

                        for (final Vec3 vec : path)
                            PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.xCoord, vec.yCoord, vec.zCoord, false));
                        break;
                    }

                    case "Multi": {
                        for (final Entity entity : targets) {
                            path = MainPathFinder.computePath(new Vec3(finalX, finalY, finalZ), new Vec3(entity.posX, entity.posY, entity.posZ));

                            for (final Vec3 vec : path)
                                PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.xCoord, vec.yCoord, vec.zCoord, true));

                            mc.thePlayer.swingItem();

                            PacketUtils.sendPacketNoEvent(new C02PacketUseEntity(entity, C02PacketUseEntity.Action.ATTACK));

                            Collections.reverse(path);

                            for (final Vec3 vec : path)
                                PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(vec.xCoord, vec.yCoord, vec.zCoord, true));
                        }
                        break;
                    }
                }
            }).start();
        }
    }

    @Override
    public void onDisable() {
        mc.timer.timerSpeed = 1;
    }

    @EventTarget
    public void onRender3DEvent(Render3DEvent event) {
        if (path == null || target == null) return;

        if (render.get()) {
            Vec3 lastPoint = null;

            final Color c = new Color(Demise.INSTANCE.getModuleManager().getModule(Interface.class).color(1));

            for (final Vec3 point : path) {
                if (lastPoint != null) {
                    RenderUtils.draw3DLine(lastPoint.xCoord, lastPoint.yCoord + 0.01, lastPoint.zCoord, point.xCoord, point.yCoord + 0.01, point.zCoord, c.getRed(), c.getGreen(), c.getBlue(), 255, 1);
                }
                lastPoint = point;
            }
        }

        if (renderESP.get()) {
            switch (mode.get()) {
                case "Single":
                    KillAura.drawCircle(target);
                    break;
                case "Multi":
                    final List<EntityLivingBase> targets = getEntities(range.get(), players.get(), nonPlayers.get(), attackDead.get(), invisibles.get(), ignoreTeammates.get());

                    for (Entity entity : targets) {
                        KillAura.drawCircle(entity);
                    }
                    break;
            }
        }
    }

    public static List<EntityLivingBase> getEntities(final double range, final boolean players, final boolean nonPlayers, final boolean dead, final boolean invisibles, final boolean ignoreTeammates) {
        return mc.theWorld.loadedEntityList.stream()

                .filter(entity -> entity instanceof EntityLivingBase)

                .map(entity -> ((EntityLivingBase) entity))

                .filter(entity -> {
                    if (entity instanceof EntityPlayer && !players) return false;

                    if (!(entity instanceof EntityPlayer) && !nonPlayers) return false;

                    if (entity.isInvisible() && !invisibles) return false;

                    if (PlayerUtils.isInTeam(entity) && ignoreTeammates) return false;

                    if (entity.isDead && !dead) return false;

                    if (entity.deathTime != 0 && !dead) return false;

                    if (entity.ticksExisted < 2) return false;

                    AntiBot antiBot = Demise.INSTANCE.getModuleManager().getModule(AntiBot.class);

                    assert entity instanceof EntityPlayer;
                    if (antiBot.isBot((EntityPlayer) entity)) return false;

                    /*
                    if (entity instanceof EntityPlayer) {
                        final EntityPlayer player = ((EntityPlayer) entity);

                        for (String name : Demise.INSTANCE.getFriendManager().getFriends()) {
                            if (name.equalsIgnoreCase(player.getGameProfile().getName()))
                                return false;
                        }
                    }
                    */

                    return mc.thePlayer != entity;
                })

                .filter(entity -> {
                    // DO NOT TOUCH THIS VALUE ITS CALCULATED WITH MATH
                    final double girth = 0.5657;

                    return mc.thePlayer.getDistanceToEntity(entity) - girth < range;
                })

                .sorted(Comparator.comparingDouble(entity -> mc.thePlayer.getDistanceSqToEntity(entity)))

                .sorted(Comparator.comparing(entity -> true))

                .collect(Collectors.toList());
    }
}